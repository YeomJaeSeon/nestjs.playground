# 가드
- 가드는 `CanActivate`인터페이스를 구현하고 `@Injectable()`데코레이터가 사용 된 클래스!
- **가드는 주어진 요청이 라우팅 핸들러에 전달 될지 말지 여부를 결정하는 단일 책임을을 갖는다**
    - 가드의 책임은 단 한개이다!(주어진 요청을 라우팅 핸들러 메서드에 전달 할지 말지)
    - 어떤 곳엥서 사용을할까? 예시를 들면 만약 로그인 하지 않은 유저가 로그인을 해야 접근할수 있는 곳에 요청할때, 라우팅 핸들러로 전달하지 못하게 하거나 (인증), 로그인을 한 유저중에서도 관리자만 요청할수 있는 리소스에 일반 유저가 요청할때 해당 요청을 라우팅 핸들러로 전달하지 못하게 해야한다.(인가)
> 가드는 인증과 인가에 자주 사용된다. 왜냐면 가드의 목적은 요청을 라우팅 핸들러로 전달 할지 말지 여부를 결정하기 때문이다.

### express에서 인증과 인가
- express에서는 미들웨어를 통해서 인증과 인가를 적용 하였다.
    - 왜? 토큰을 검증하거나 Request 객체 프로퍼리를 설정하는 등의 일은 '라우팅 핸들러 메서드'와 하는일과 분리되기 때문에 라우팅 핸들러 메서드로 요청이 오기전에 미리 해당 작업들을 하였다. 이때 미들웨어가 적절하기에 Express는 미들웨어를 사용하여 인증 인가를 구현하곤 했다.
- 그러나 미들웨어는 자신 다음의 함수를 `next()`함수로 호출하는데, 어떤 핸들러가 실행될지 모른다. 
    - 내 생각에는 'next()로 다음 함수를 호출하면 어떤 함수가 올지 모른다'라는 말은 어떠한 실행 컨텍스트가 콜스택에 쌓일지 모른다는 의미인듯 하다. 


### NestJS에서 인증과 인가
- 가드는 미들웨어와 다르게 `ExecutionContext` 실행 컨텍스트 인스턴스에 접근이 가능하기에 다음에 무엇이 실행하는지 알 수 있다.(코어 자바스크립트에선 outerEnvironmentReference가 이전 실행 컨텍스트의 LexicalEnvironment를 참조한다 하였는데, 이를 통해서 아는 것일까? 왠지 맞을거 같다.)
> 항상 코어자바스크립트랑 연관지어 자바스크립트 기본동작 방식과 엮어 생각해보자.
    - (여기서 잠깐! 실행 컨텍스트란? 코드 실행에 필요한 환경정보를 모아놓은 객체이다.)
- 가드는 예외필터, 파이프와 마찬가지로 미들웨어 일종이기에 요청/응답 사이클의 적당한 시점에서 처리할수 있게 해준다.
    - 미들웨어 -> (가드) -> 인터셉터, 파이프 : 가드 실행 시점

## 인가 가드

- 가드는 인가에 사용하기 매우 적절하다.
    - 요청을 요청핸들러 메서드로 보낼지 말지 결정하는 녀석이 가드이기에 인가 기능을 구현하는데 매우 적절하다.

```typescript
@Injectable()
export class AuthGuard implements CanActivate{
    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        const request = context.switchToHttp().getRequest();
        this.validateRequest(request)

        return true;
    }

    validateRequest(request : Request){
        if(!request.headers.authorization || request.headers.authorization != 'password'){
            throw new UnauthorizedException()
        }
    }
}
```