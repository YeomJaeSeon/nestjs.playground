# 가드
- 가드는 `CanActivate`인터페이스를 구현하고 `@Injectable()`데코레이터가 사용 된 클래스!
- **가드는 주어진 요청이 라우팅 핸들러에 전달 될지 말지 여부를 결정하는 단일 책임을을 갖는다**
    - 가드의 책임은 단 한개이다!(주어진 요청을 라우팅 핸들러 메서드에 전달 할지 말지)
    - 어떤 곳엥서 사용을할까? 예시를 들면 만약 로그인 하지 않은 유저가 로그인을 해야 접근할수 있는 곳에 요청할때, 라우팅 핸들러로 전달하지 못하게 하거나 (인증), 로그인을 한 유저중에서도 관리자만 요청할수 있는 리소스에 일반 유저가 요청할때 해당 요청을 라우팅 핸들러로 전달하지 못하게 해야한다.(인가)
> 가드는 인증과 인가에 자주 사용된다. 왜냐면 가드의 목적은 요청을 라우팅 핸들러로 전달 할지 말지 여부를 결정하기 때문이다.

### express에서 인증과 인가
- express에서는 미들웨어를 통해서 인증과 인가를 적용 하였다.
    - 왜? 토큰을 검증하거나 Request 객체 프로퍼리를 설정하는 등의 일은 '라우팅 핸들러 메서드'와 하는일과 분리되기 때문에 라우팅 핸들러 메서드로 요청이 오기전에 미리 해당 작업들을 하였다. 이때 미들웨어가 적절하기에 Express는 미들웨어를 사용하여 인증 인가를 구현하곤 했다.
- 그러나 미들웨어는 자신 다음의 함수를 `next()`함수로 호출하는데, 어떤 핸들러가 실행될지 모른다. 
    - 내 생각에는 'next()로 다음 함수를 호출하면 어떤 함수가 올지 모른다'라는 말은 어떠한 실행 컨텍스트가 콜스택에 쌓일지 모른다는 의미인듯 하다. 


### NestJS에서 인증과 인가
- 가드는 미들웨어와 다르게 `ExecutionContext` 실행 컨텍스트 인스턴스에 접근이 가능하기에 다음에 무엇이 실행하는지 알 수 있다.(코어 자바스크립트에선 outerEnvironmentReference가 이전 실행 컨텍스트의 LexicalEnvironment를 참조한다 하였는데, 이를 통해서 아는 것일까? 왠지 맞을거 같다.)
> 항상 코어자바스크립트랑 연관지어 자바스크립트 기본동작 방식과 엮어 생각해보자.
    - (여기서 잠깐! 실행 컨텍스트란? 코드 실행에 필요한 환경정보를 모아놓은 객체이다.)
- 가드는 예외필터, 파이프와 마찬가지로 미들웨어 일종이기에 요청/응답 사이클의 적당한 시점에서 처리할수 있게 해준다.
    - 미들웨어 -> (가드) -> 인터셉터, 파이프 : 가드 실행 시점

## 인가 가드

- 가드는 인가에 사용하기 매우 적절하다.
    - 요청을 요청핸들러 메서드로 보낼지 말지 결정하는 녀석이 가드이기에 인가 기능을 구현하는데 매우 적절하다.

```typescript
@Injectable()
export class AuthGuard implements CanActivate{
    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        const request = context.switchToHttp().getRequest();
        this.validateRequest(request)

        return true;
    }

    validateRequest(request : Request){
        if(!request.headers.authorization || request.headers.authorization != 'password'){
            throw new UnauthorizedException()
        }
    }
}
```

## 실행 컨텍스트 (ExecutonContext)
- 가드를 만드는데 필요한 인터페이스인 `CanActivate`를 구현하는 데 필요한 메서드 `canActivate`의 유일한 파라미터이다.
- `ExecutionContext`는 `ArgumentHost`를 상속한다.
  - `ArgumentHost`를 이용해 Request객체에 접근할수 있다고 한다. 
- `ExecutionContext`는 `ArgumentHost`를 확장하여 더 많은 기능을 한다. 구레서 컨트롤러 메서드 실행컨텍스트를 모두 아우르는 광범위한 **범용적 가드**를 만들 수 있다.

## 가드 등록
- 파이프, 필터와 마찬가지로 클래스레벨, 메서드 레벨 그리고 전역수준에서 가드를 등록 할 수 있다.
  - new를 통해 인스턴스를 넣어 등록할 수도 있지만! 클래스를 넣어야 네스트가 인스턴스를 관리하여 메모리 관리를 쉽게 한다고 했었따! (저번에)
  - 그리고 new를 사용하지 않아야만 DI가 가능하다고 한다.
    - 인스턴스를 넣으면 네스트가 관리하지 못하니 그런거라 생가한다.

### 컨트롤러 수준에서 등록
- `@UseFilters()`, `@UsePipes()`와 마찬가지로 `@UseGuards()`라는 데코레이터를 통해서 등록할 수 있다.
- 컨트롤러 위에 `@UseGuards()`를 붙이고 데코레이터엔 클래스를 넣자.(인스턴스 넣어도 된다 그치만 단점 알쥐?)

### 라우팅 핸들러 수준에서 등록
- 메서드 위에 `@UseGuards()`붙이면 핸들러 메서드 수준에만 가드가 적용이되어, 요청을 핸들러 메서드로 보낼지 말지 결정한다.

### 전역으로 등록
- `app.useGlobalGuards(new AuthGuard())`이렇게 사용한다.
- 전역이니 네스트 모듈이 범위 밖이므로 네스트가 알아서 가드의 인스턴스를 만들 수 없기에, 인스턴스를 넣어야한다.

## 역할 기반 인증 가드
- 실제로 동작하는 인증 가드를 만들어 보자!
- 읽었는데 잘 이해가 가지 않는다. 리플레션이란 뭔지 Metadata란 뭔지 모르겠다. NestJS의 실행컨텍스트를 공부하고 다시 보자
