# 컨트롤러
- 컨트롤러는 어플리케이션으로 들어오는 **요청 처리**하고 나가는 **응답 반환**하는 역할을 하는 layer이다.
- NestJS는 컨트롤러를 만들기 위해 클래스와 데코레이터를 사용한다.
    - 마취 슾흐링과 매우 유사한걸 알수있다!!

> 그런데 NestJS는 express에서 라우터를 지정해주는 작업은 안해도 되나봐? - 개발자는 라우터 신경쓰지않아도 된다.
> `nest g resource <module name>`을 통해 name모듈의 컨트롤러 서비스 CRUD를 간단하게 만들수있다.

## 라우팅
- 컨트롤러로 지정할 클래스 위에 `@Controller()`를 붙이면 컨트롤러가 된다. 하즤만 nest cli를 통해서 generate하면 만들어져있따.
    - 슾흐링과 매우 유사하다. `@Controller`애너테이션과 매우 유사하지 않나?
- 클래스 레벨에 붙은 데코레이터 `@Controller()`의 파라미터에 접두사를 붙이면 클래스 하위 메서드 라우팅을 그룹화 가 가능하다. 
    - `@Controller('car')`처럼 'car'을 넣으면 해당 컨트롤러 클래스의 메서드는 모두 car/~ 로 라우팅이 된다.
    - 이또한 슾흐링과 매우 유사하다!

> `nest g controller <module name>`으로 대박 쉽게 컨트롤러 generate가능!

- `@Controller('car')`이 붙은 클래스의 메서드에 `@Get()`의 데코레이터를 붙이면 '/car'의 url로 GET메서드로 HTTP요청할때 해당 메서드에 매핑된다.
    - 슾흐링의 `@GetMapping`애너테이션과 또 유사한걸 알수있다!

> 메서드 이름은 편할대로 ~ 당연히 기능을 수행하는 동작에 맞는 이름이긴 해야겠다.

## 응답 두가지 방법
- Nest에선 응답을 두가지 방법으로 처리한다.

1. 표준(권장) : 객체나 배열로 리턴하면 Nest가 이를 JSON으로 알아서 변경하여 응답(직렬화 Nest가 해준다.) primitive type리턴하면 문자열로 응답해준다..!
    - Spring은 message converter가 http 메시지와 응답 데이터 타입을 통해서 적절히 컨버터 해주는데 Nest도 내부적으로 적절히 변경해서 내려주는듯하다.
    - NestJS는 이 방법을 권장한다.
2. express나 fastify에서 사용하는 방법을 이용 : express에서 응답하는 방법을 이용해 Response객체를 통해서 `response.status(200).send()`를 이용할 수도 있따.

> NestJS는 내부적인 플랫폼 express, fastify를 이용하므로 해당 플랫폼에서 사용하던 방식 또한 사용할수 있다. 그러나 Nest는 해당 플랫폼을 추상화하여 개발자로 하여금 사용하기 더 편하게 만들어놨으니 굳이 사용하지 않을 이유는 없다!

## 요청 객체
- Nest 컨트롤러의 핸들러 메서드는 요청 객체에 어떻게 접근하나?
    - 내부적으로 express(Default)를 사용한다면 express의 Request객체를 사용할수 있다.
    - 핸들러 메서드 파라미터에 `@Req()` 데코레이터를 통해 request를 사용할수 있다.
    - `@Req()`데코레이터를 핸들러 메서드 파라미터에 적지않으면 express의 Request객체 사용할수 없다.(undefined뜬다)
    - `@Body()`, `@Query()`, `@Headers()`등으로 Request객체의 특정 프로퍼티에 바로 접근할수 있다.
    
    > 프로퍼티란? 객체의 모든 속성을 일컫는 말. (by 객체지향의 사실과 오해)

## 리소스
- REST API를 사용하는 경우 특정 HTTP 메서드에 매핑되는 핸들러를 정의하는 것도 또한 데코레이터를 이용!
- `@Get()`, `@Post()`, `@Put()`, `@Patch()`, `@Delete()` ..

## 라우트 와일드카드
- '*'를 이용해서 패턴 기반 경로도 설정할수있다.
    - ex) `@Get('ap*e')` -> GET /apple, GET /ape, GET /apasdasdfasdfe ... 모두 가능

## 상태코드 (status code)
- POST요청을 제외하곤 default가 200이다. (POST는 성공시 201이 default!)
- 물론 핸들러 메서드 위에 `@HttpCode(<status code: number>)`를 붙이면 내가원하는 상태코드를 응답가능!
- 상황에 따라 동적으로 변하는 상태코드는 `@Res()`를 이용하자! -> ? express가 하던대로 응답하는게 맞는건가? Nest에선 자동으로 직렬화도 해주는 그러한 기능을 제공하는데 .(ex) 객체 -> json)
    - 상황에 따라 다른 상태코드를 내려주려면 `@Res()`를 무조건 사용해야하나?

## 헤더
- 응답하고 싶은 헤더를 지정할땐 `@Header()`를 핸들러 메서드 레벨에 붙인다.
- 물론 Response객체를 이용해도 된다.

## 리다이렉션
- 핸들러 메서드 레벨에 `@Redirect('url')`을 붙인다.
    - `@Redirect()`데코레이터의 파라미터로 넣는 오브젝트는 `{"url": string, "statusCode": number}`이다. (주소만 넣어도된다!)
- 당연하게도 Response객체를 이용해도 된다.

## 경로 매개변수 (PathVariable)
- 핸들러 메서드 파라미터에 `@Param()`을 이용해서 경로 매개변수에 접근가능
    - `@Param('id') id: string`이런식으로 특정 경로매개변수에도 바로 접근가능

## 하위 도메인 라우팅
- HTTP 호스트 (경로가 아니라 호스트임! ex) 호스트: localhost:3000, 경로 : /cats)를 특정 호스트와 일치하도록 컨트롤러 클래스레벨에 정의할수 있다.

## 컨트롤러 스코프
- NestJS 컨트롤러는 기본 스코프는 싱글턴이다.
    - 요청 응답은 하나의 컨트롤러 인스턴스를 공유해 사용한다. (심지어 JavaScript 는 싱글스레드이므로 멀티스레드 언어보다 더 안전하겠다.)

## 비동기 핸들러
- NestJS를 사용하면 비동기적인 작업이 자주 일어난다. (ex) 데이터베이스에 연결해서 데이터를 조회하는 ..)
- 그렇기에 컨트롤러의 핸들러 메서드는 Promise에 대한 async await을 잘 처리한다.! (Promise를 리턴해도 잘 처리가 된다..!!)

## 요청 페이로드 데이터와 DTO (@Body)
- POST 메서드를 이용해 요청하는 경우 http request body에 데이터를 넣어서 요청한다.
- 이떄 핸들러 메서드의 파라미터에 `@Body()`를 넣어서 요청 데이터를 받을 수 있고, DTO 타입으로 받으면 알아서 요청 데이터가 DTO 타입에 맞게 인스턴스가 하나 생성되어 메서드에서 받는다. (DTO가 클래스일때!, interface, type은 인스턴스 생성안된다!)

> 추후에 validationPipe와 함께 사용하여 요청 데이터 validation검증도 가능하다!

## 컨트롤러 사용 등록
- 컨트롤러만 존재한다해서, 클래스를 만들고 위에 `@Controller()`를 만들었다 해서 Nest가 컨트롤러를 인식하진 못한다.
- 컨트롤러는 모듈의 'controllers'프로퍼티에 들어가 있어야한다! (컨트롤러는 모듈에 종속되어있어야 Nest가 컨트롤러로 인식한다)

## 응답 처리
- `@Res()`를 이용해서 원하는데이터와 원하는 status code를 응답할수 있다. (물론 @HttpCode를 이용하거나, 그냥 오브젝트를 리턴해도된다.)
- 그러나 위 방법은 express의 Response객체를 사용하는 방버이기에 여러 단점이 있따.
    1. fastify를 사용하면 제대로 동작하지 않을 것이다. -> Nest가 제공하는 기능만 사용하면 추상화가 잘되어있어 어떤 플랫폼을 사용하던 상관이 없지만 express의 기능을 선택해서 사용하면 fastify플랫폼에는 동작하지 않는다는 의미이다.
    2. 테스트 하기가 어려워진다. (Response)객체를 모킹해야하는데 귀찮다. 그냥 객체를 리턴한다하면 모킹할 필요가 없으니 당연히 테스트하기 용이하겠다.
    3. Nest와의 호환성 일부를 잃는다. Nest에서 제공하는 인터셉터, @HttpCode()등을 사용하지 못한다. (`@Res({passthrough: true}) res: Response`를 통해서 타협이 가능하다곤한다.)