# 컨트롤러
- 컨트롤러는 어플리케이션으로 들어오는 **요청 처리**하고 나가는 **응답 반환**하는 역할을 하는 layer이다.
- NestJS는 컨트롤러를 만들기 위해 클래스와 데코레이터를 사용한다.
    - 마취 슾흐링과 매우 유사한걸 알수있다!!

> 그런데 NestJS는 express에서 라우터를 지정해주는 작업은 안해도 되나봐? - 개발자는 라우터 신경쓰지않아도 된다.
> `nest g resource <module name>`을 통해 name모듈의 컨트롤러 서비스 CRUD를 간단하게 만들수있다.

## 라우팅
- 컨트롤러로 지정할 클래스 위에 `@Controller()`를 붙이면 컨트롤러가 된다. 하즤만 nest cli를 통해서 generate하면 만들어져있따.
    - 슾흐링과 매우 유사하다. `@Controller`애너테이션과 매우 유사하지 않나?
- 클래스 레벨에 붙은 데코레이터 `@Controller()`의 파라미터에 접두사를 붙이면 클래스 하위 메서드 라우팅을 그룹화 가 가능하다. 
    - `@Controller('car')`처럼 'car'을 넣으면 해당 컨트롤러 클래스의 메서드는 모두 car/~ 로 라우팅이 된다.
    - 이또한 슾흐링과 매우 유사하다!

> `nest g controller <module name>`으로 대박 쉽게 컨트롤러 generate가능!

- `@Controller('car')`이 붙은 클래스의 메서드에 `@Get()`의 데코레이터를 붙이면 '/car'의 url로 GET메서드로 HTTP요청할때 해당 메서드에 매핑된다.
    - 슾흐링의 `@GetMapping`애너테이션과 또 유사한걸 알수있다!

> 메서드 이름은 편할대로 ~ 당연히 기능을 수행하는 동작에 맞는 이름이긴 해야겠다.

## 응답 두가지 방법
- Nest에선 응답을 두가지 방법으로 처리한다.

1. 표준(권장) : 객체나 배열로 리턴하면 Nest가 이를 JSON으로 알아서 변경하여 응답(직렬화 Nest가 해준다.) primitive type리턴하면 문자열로 응답해준다..!
    - Spring은 message converter가 http 메시지와 응답 데이터 타입을 통해서 적절히 컨버터 해주는데 Nest도 내부적으로 적절히 변경해서 내려주는듯하다.
    - NestJS는 이 방법을 권장한다.
2. express나 fastify에서 사용하는 방법을 이용 : express에서 응답하는 방법을 이용해 Response객체를 통해서 `response.status(200).send()`를 이용할 수도 있따.

> NestJS는 내부적인 플랫폼 express, fastify를 이용하므로 해당 플랫폼에서 사용하던 방식 또한 사용할수 있다. 그러나 Nest는 해당 플랫폼을 추상화하여 개발자로 하여금 사용하기 더 편하게 만들어놨으니 굳이 사용하지 않을 이유는 없다!

## 요청 객체
TODO: 2.15