# 주입 스코프

- NestJS 는 Node.js환경에서의 서버 프레임워크이기에, 싱글스레드로 실행된다.(자바스크립트는 싱글쓰레드 언어이다. 단일 콜스택으로 구성됨)
- 문서에선 'NestJS에서 싱글턴 디자인패턴을 사용해도 안전하다' 라고 말한다.
    - 자바와 같은 멀티쓰레드 환경에서 싱글턴 디자인 패턴을 이용하면 하나의 인스턴스를 여러쓰레드가 동시에 접근할수도있기에 안전하지 않다는 것으로 판단된다. 싱글쓰레드이면 애초에 그럴일이 없기에 안전하다라고 하는것 같다.
- NestJS에서 사용되는 인스턴스(프로바이더, 컨트롤러..)의 스코프(생명주기)를 지정할 수 있다. 싱글턴, 요청때마다 인스턴스 생성, TRANSIENT(프로바이더를 사용하는 곳마다 새로운 인스턴스를 만듬)
    - 스프링빈의 생명주기를 지정하는 것과 유사한듯하다. 심지어 Node환경이기에 싱글턴은 안전하기까지!

> DI 대상이 되는 인스턴스의 생명주기를 지정할수 있다. 컨트롤러, 프로바이더. 또 이것들 말고 있을까?

## 스코프 종류
- DEFAULT: 디폴트로 주입 스코프가 싱글턴이다. 싱글턴이기에 전체앱에서 하나의 인스턴스를 공유하며, 어플리케이션 생명주기와 동일하다. 네스트 어플 부트스트랩될때 인스턴스 생성되고 어플리케이션 종료될때, 싱글턴 인스턴스도 죽는다.
- REQUEST: **요청** 마다 새로운 인스턴스가 생성된다. 요청 처리가 완료되면 GC에 의해 메모리에서 수거된다. (요청에 대한 응답이 끝나면 참조카운트가 0 이라 GC에서 바로 수거되는가? 아니면 일정 시간 있어야만 수거되는가?)
- TRANSIENT: 프로바이더를 사용하는 곳마다 인스턴스 생성한다. 
    - A모듈에 A서비스를 프로바이더로 지정하고, A모듈의 A클래스에서 A프로바이더 DI하고, B모듈에서 A프로바이더 DI하면, 최초에 어플실행할때, A 프로바이더 인스턴스 두개 생성된다.

## 프로바이더에 스코프 지정

- `@Injectable()`데코레이터에서 스코프 지정할수도있음
```typescript
@Injectable({ scope: Scope.REQUEST })
export class CatsService {
}

```

- 프로바이더라면, 해당 프로바이더를 지정하는 모듈에서 스코프를 지정할수도있음 (축약된 문법사용하지않고 축약하지 않은 문법을 사용해서)
```typescript
@Module({
  providers: [
    {
      provide: CatsService,
      useClass: CatsService,
      scope: Scope.REQUEST, //요렇게~
    },
  ],
  controllers: [CatsController],
  exports: [CatsService],
})
export class CatsModule {}

```

## 컨트롤러에도 스코프 지정할수있음
```typescript
@Controller({ path: 'cats', scope: Scope.REQUEST }) //참쉽죠?
export class CatsController {
}

```

## 스코프전이
- 스코프를 지정한 프로바이더를 의존하는 컨트롤러도 프로바이더 지정한 스코프(생명주기)가 된다.
    - A 서비스 프로바이더의 스코프를 REQUEST로 지정하였을때, A 서비스를 의존하는 A 컨트롤러는 자동으로 REQUEST 스코프가된다.

## 요청스코프에서 요청 객체 사용
- 요청스코프에선 요청 할 때마다 새로운 인스턴스가 생성된다. 그래서 원본 요청객체에 `@Req()`으로 가져오기 힘들다. 이럴땐 `@nestjs/core`의 `REQUEST`를 이용하여 주입하면 된다.
```typescript
@Injectable({ scope: Scope.REQUEST })
export class CatsService {
  constructor(@Inject(REQUEST) private request: Request) {} // 이렇게 @Inject를 이용해서 토큰을 이용해서 DI하면된다.
}
```

## 성능 관점에서 스코프 주입 다시보기
- **네스트에서는 내부적으로 성능향상을 위해 가능한 많은 메타데이터를 캐싱한다.** 그렇기에 요청스코프를 하면 이 캐싱데이터를 사용하지않고 무자비하게 요청마다 인스턴스를 만들어버리기에 캐싱의 이점을 살릴 수 없다. 또, 요청스코프에선 계속 인스턴스를 생성하기에 메모리 소모가 싱글턴 스코프 보다 크다. 그래서 **네스트에선 DEFAULT로 제공하는 싱글톤 스코프를 사용하기를 강력하게 권장한다.**

## 네스트에서 프로바이더 적절하게 사용하라
- 모듈을 통해서 다른 모듈의 프로바이더를 DI하는게 아니고 바로 여러모듈에서 하나의 프로바이더를 각각 프로바이더로 지정하면, 해당 프로바이더를 싱글턴 스코프로 지정 하더라도 프로바이더로 지정한 개수만큼 인스턴스가 생성된다. 해당 프로바이더를 다른 모듈에서 사용하려면 **module**을 통해 사용해야 불필요한 인스턴스를 생성하지 않는다. 네스트에서 가이드하는 방법으로 프로바이더 DI를 하자
    - 다른모듈에서 해당 모듈의 프로바이더 DI하려면 해당모듈에선 `exports`에 해당 프로바이더를 지정하고, 다른 모듈에선 `imports`로 해당 모듈을 import한다.